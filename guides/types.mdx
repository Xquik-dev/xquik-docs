---
title: Type Definitions
description: TypeScript type definitions for all API request and response objects
keywords: ["typescript", "type definitions", "interfaces", "request types", "response types"]
---

Copy-pasteable TypeScript types for every Xquik API object. Use these in your client code for full type safety.

```typescript
// ─── Account ─────────────────────────────────────────────

interface Account {
  plan: "active" | "inactive";
  monitorsAllowed: number;
  monitorsUsed: number;
  currentPeriod?: {
    start: string;
    end: string;
    usagePercent: number;
  };
}

// ─── API Keys ────────────────────────────────────────────

// Returned when creating a new key (includes full key)
interface ApiKeyCreated {
  id: string;
  fullKey: string;
  prefix: string;
  name: string;
  createdAt: string;
}

// Returned when listing keys (full key is never exposed)
interface ApiKey {
  id: string;
  name: string;
  prefix: string;
  isActive: boolean;
  createdAt: string;
  lastUsedAt?: string;
}

// ─── Monitors ────────────────────────────────────────────

interface Monitor {
  id: string;
  username: string;
  xUserId: string;
  eventTypes: EventType[];
  isActive: boolean;
  createdAt: string;
}

type EventType =
  | "tweet.new"
  | "tweet.quote"
  | "tweet.reply"
  | "tweet.retweet"
  | "follower.gained"
  | "follower.lost";

// ─── Events ──────────────────────────────────────────────

interface Event {
  id: string;
  type: EventType;
  monitorId: string;
  username: string;
  occurredAt: string;
  data: EventData;
  xEventId?: string;
}

// Tweet events (tweet.new, tweet.reply, tweet.quote, tweet.retweet)
interface TweetEventData {
  tweetId: string;
  text: string;
  metrics: {
    likes: number;
    retweets: number;
    replies: number;
  };
  // tweet.quote only
  quotedTweetId?: string;
  quotedUsername?: string;
  // tweet.reply only
  inReplyToTweetId?: string;
  inReplyToUsername?: string;
  // tweet.retweet only
  retweetedTweetId?: string;
  retweetedUsername?: string;
}

// Follower events (follower.gained, follower.lost)
interface FollowerEventData {
  followerId: string;
  followerUsername: string;
  followerName: string;
  followerFollowersCount: number;
  followerVerified: boolean;
}

type EventData = TweetEventData | FollowerEventData;

interface EventList {
  events: Event[];
  hasMore: boolean;
  nextCursor?: string;
}

// ─── Webhooks ────────────────────────────────────────────

// Returned when creating a webhook (includes signing secret)
interface WebhookCreated {
  id: string;
  url: string;
  eventTypes: EventType[];
  secret: string;
  createdAt: string;
}

// Returned when listing webhooks (secret is never exposed)
interface Webhook {
  id: string;
  url: string;
  eventTypes: EventType[];
  isActive: boolean;
  createdAt: string;
}

// ─── Deliveries ──────────────────────────────────────────

interface Delivery {
  id: string;
  streamEventId: string;
  status: "pending" | "delivered" | "failed" | "exhausted";
  attempts: number;
  lastStatusCode?: number;
  lastError?: string;
  createdAt: string;
  deliveredAt?: string;
}

// ─── Webhook Payload ─────────────────────────────────────

// What your webhook endpoint receives as the POST body
interface WebhookPayload {
  eventType: EventType;
  username: string;
  data: EventData;
}

// ─── Error Response ──────────────────────────────────────

interface ApiError {
  error: string;
  limit?: number; // only present for monitor_limit_reached
}

// ─── Request Bodies ──────────────────────────────────────

interface CreateMonitorRequest {
  username: string;
  eventTypes: EventType[];
}

interface UpdateMonitorRequest {
  eventTypes?: EventType[];
  isActive?: boolean;
}

interface CreateWebhookRequest {
  url: string;
  eventTypes: EventType[];
}

interface UpdateWebhookRequest {
  url?: string;
  eventTypes?: EventType[];
  isActive?: boolean;
}

interface CreateApiKeyRequest {
  name?: string;
}

// ─── Draws ──────────────────────────────────────────────

interface Draw {
  id: string;
  tweetId: string;
  tweetUrl: string;
  tweetText: string;
  tweetAuthorUsername: string;
  tweetLikeCount: number;
  tweetRetweetCount: number;
  tweetReplyCount: number;
  tweetQuoteCount: number;
  status: "pending" | "running" | "completed" | "failed";
  totalEntries: number;
  validEntries: number;
  createdAt: string;
  drawnAt?: string;
}

interface DrawListItem {
  id: string;
  tweetUrl: string;
  status: "pending" | "running" | "completed" | "failed";
  totalEntries: number;
  validEntries: number;
  createdAt: string;
  drawnAt?: string;
}

interface DrawWinner {
  position: number;
  authorUsername: string;
  tweetId: string;
  isBackup: boolean;
}

interface DrawList {
  draws: DrawListItem[];
  hasMore: boolean;
  nextCursor?: string;
}

interface CreateDrawRequest {
  tweetUrl: string;
  winnerCount?: number;
  backupCount?: number;
  uniqueAuthorsOnly?: boolean;
  mustRetweet?: boolean;
  mustFollowUsername?: string;
  filterMinFollowers?: number;
  filterAccountAgeDays?: number;
  filterLanguage?: string;
  requiredKeywords?: string[];
  requiredHashtags?: string[];
  requiredMentions?: string[];
}

// ─── Extractions ────────────────────────────────────────

type ExtractionToolType =
  | "article_extractor"
  | "community_extractor"
  | "community_moderator_explorer"
  | "community_post_extractor"
  | "community_search"
  | "follower_explorer"
  | "following_explorer"
  | "list_follower_explorer"
  | "list_member_extractor"
  | "list_post_extractor"
  | "mention_extractor"
  | "people_search"
  | "post_extractor"
  | "quote_extractor"
  | "reply_extractor"
  | "repost_extractor"
  | "space_explorer"
  | "thread_extractor"
  | "verified_follower_explorer";

interface ExtractionJob {
  id: string;
  toolType: ExtractionToolType;
  status: "pending" | "running" | "completed" | "failed";
  totalResults: number;
  targetTweetId?: string;
  targetUsername?: string;
  targetUserId?: string;
  targetCommunityId?: string;
  targetListId?: string;
  targetSpaceId?: string;
  searchQuery?: string;
  aiTitles?: { en: string; tr: string; es: string };
  errorMessage?: string;
  createdAt: string;
  completedAt?: string;
}

interface ExtractionResult {
  id: string;
  xUserId: string;
  xUsername?: string;
  xDisplayName?: string;
  xFollowersCount?: number;
  xVerified?: boolean;
  xProfileImageUrl?: string;
  tweetId?: string;
  tweetText?: string;
  tweetCreatedAt?: string;
  createdAt: string;
}

interface ExtractionList {
  extractions: ExtractionJob[];
  hasMore: boolean;
  nextCursor?: string;
}

interface ExtractionEstimate {
  allowed: boolean;
  source: "replyCount" | "retweetCount" | "quoteCount" | "followers" | "unknown";
  estimatedResults: number;
  usagePercent: number;
  projectedPercent: number;
  error?: string;
}

interface CreateExtractionRequest {
  toolType: ExtractionToolType;
  targetTweetId?: string;
  targetUsername?: string;
  targetCommunityId?: string;
  targetListId?: string;
  targetSpaceId?: string;
  searchQuery?: string;
}

// ─── X API ──────────────────────────────────────────────

interface TweetMediaItem {
  mediaUrl: string;
  type: string;
  url: string;
}

interface Tweet {
  id: string;
  text: string;
  createdAt?: string;
  retweetCount: number;
  replyCount: number;
  likeCount: number;
  quoteCount: number;
  viewCount: number;
  bookmarkCount: number;
  media?: TweetMediaItem[];
}

interface TweetAuthor {
  id: string;
  username: string;
  followers: number;
  verified: boolean;
  profilePicture?: string;
}

interface TweetSearchResult {
  id: string;
  text: string;
  createdAt: string;
  likeCount: number;
  retweetCount: number;
  replyCount: number;
  author: {
    id: string;
    username: string;
    name: string;
    verified: boolean;
  };
  media?: TweetMediaItem[];
}

interface UserProfile {
  id: string;
  username: string;
  name: string;
  description?: string;
  followers?: number;
  following?: number;
  verified?: boolean;
  profilePicture?: string;
  location?: string;
  createdAt?: string;
  statusesCount?: number;
}

interface FollowerCheck {
  sourceUsername: string;
  targetUsername: string;
  isFollowing: boolean;
  isFollowedBy: boolean;
}

// ─── Trends ─────────────────────────────────────────────

interface Trend {
  name: string;
  description?: string;
  rank?: number;
  query?: string;
}

interface TrendList {
  trends: Trend[];
  total: number;
  woeid: number;
}

// ─── Styles ─────────────────────────────────────────────

interface StyleTweet {
  id: string;
  authorUsername: string;
  text: string;
  createdAt: string;
  media?: TweetMediaItem[];
}

interface StyleProfile {
  xUsername: string;
  isOwnAccount: boolean;
  tweetCount: number;
  fetchedAt: string;
  tweets: StyleTweet[];
}

interface StyleListItem {
  xUsername: string;
  isOwnAccount: boolean;
  tweetCount: number;
  fetchedAt: string;
}

interface StyleList {
  styles: StyleListItem[];
}

interface StyleComparison {
  style1: StyleProfile;
  style2: StyleProfile;
}

interface PerformanceTweet {
  id: string;
  text: string;
  likeCount: number;
  retweetCount: number;
  replyCount: number;
  quoteCount: number;
  viewCount: number;
  bookmarkCount: number;
}

interface PerformanceAnalysis {
  xUsername: string;
  tweetCount: number;
  tweets: PerformanceTweet[];
}

// ─── Drafts ─────────────────────────────────────────────

interface Draft {
  id: string;
  text: string;
  topic?: string;
  goal?: "engagement" | "followers" | "authority" | "conversation";
  createdAt: string;
  updatedAt: string;
}

interface DraftList {
  drafts: Draft[];
  hasMore: boolean;
  nextCursor?: string;
}

interface CreateDraftRequest {
  text: string;
  topic?: string;
  goal?: "engagement" | "followers" | "authority" | "conversation";
}
```

## REST API vs MCP Field Naming

<Info>
  The REST API and MCP server use different field names for the same data. Map these when switching between interfaces:

  | Type | REST API Field | MCP Field |
  |------|---------------|-----------|
  | **Monitor** | `username` | `xUsername` |
  | **Event** | `type` | `eventType` |
  | **Event** | `data` | `eventData` |
  | **Event** | `monitorId` | `monitoredAccountId` |
  | **UserProfile** | `followers` | `followersCount` |
  | **UserProfile** | `following` | `followingCount` |
  | **FollowerCheck** | `isFollowing` / `isFollowedBy` | `following` / `followedBy` |
</Info>

<Warning>
  **MCP `get-user-info` returns a subset** of the full `UserProfile` type. Fields not returned by MCP: `verified`, `location`, `createdAt`, `statusesCount`. Use the REST API `GET /x/users/{username}` for the complete profile.
</Warning>

## Type Reference

### Account

Returned by `GET /api/v1/account`. The `currentPeriod` field is omitted when there is no active subscription. `usagePercent` is an integer (0-100) representing how much of the monthly quota has been consumed.

### API Keys

Two shapes exist: `ApiKeyCreated` is returned only from `POST /api/v1/api-keys` and includes the `fullKey` field. This is the only time the full key is exposed. `ApiKey` is returned by `GET /api/v1/api-keys` and shows only the `prefix` (first 8 characters) for identification.

### Monitors

Returned by all monitor endpoints. The `xUserId` is the X (Twitter) user ID resolved from the `username` at creation time. `eventTypes` controls which event types this monitor tracks.

### Events

`Event` represents a single tracked action from a monitored account. The `data` field shape depends on the event type: tweet events contain `tweetId`, `text`, and `metrics`, while follower events contain `followerId`, `followerUsername`, `followerName`, `followerFollowersCount`, and `followerVerified`. Tweet subtypes include additional fields (`quotedTweetId` for quotes, `inReplyToTweetId` for replies, `retweetedTweetId` for retweets). `EventList` wraps paginated responses. Use `nextCursor` with the `after` query parameter to fetch subsequent pages.

### Webhooks

Similar to API keys, webhooks have two shapes. `WebhookCreated` includes the `secret` field used for HMAC signature verification. `Webhook` (from list/get) never exposes the secret. If you lose the secret, delete and recreate the webhook.

### Deliveries

Each `Delivery` represents one attempt to send an event to a webhook endpoint. Status progresses from `pending` to `delivered` (success) or through `failed` to `exhausted` (all retries failed). `lastStatusCode` and `lastError` help diagnose delivery failures.

### Webhook Payload

The `WebhookPayload` type describes the JSON body your endpoint receives on each delivery. It contains only 3 fields: the event type, the monitored username, and the event data. Verify its authenticity using the `X-Xquik-Signature` header and your webhook secret. See [Webhook Verification](/webhooks/verification) for implementation details.

### Draws

`Draw` is the full draw object returned by `GET /api/v1/draws/:id` with tweet metadata and engagement counts. `DrawListItem` is the compact shape returned in list responses. `DrawWinner` contains the position, username, tweet ID, and backup flag for each winner. Filter fields on `CreateDrawRequest` control which entries qualify for the draw.

### Extractions

`ExtractionJob` represents a completed or failed extraction job. The target fields (`targetTweetId`, `targetUsername`, etc.) vary by `toolType`. `ExtractionResult` contains the core user and tweet data returned by the API. Results are paginated in the get endpoint with up to 1,000 results per page. Exports (CSV, XLSX, Markdown) include additional enrichment columns not present in the API response. See [Export Extraction](/api-reference/extractions/export) for the full column list. `ExtractionEstimate` previews the cost before running a job.

### X API

Direct X data lookup types. `Tweet` and `TweetAuthor` are returned by the tweet lookup endpoint. `TweetSearchResult` is returned in search results with an inline `author` object. `UserProfile` contains the full user profile. `FollowerCheck` returns the bidirectional follow relationship between two users. Both `Tweet` and `TweetSearchResult` include an optional `media` array of `TweetMediaItem` objects, present only when the tweet has attached media. Media types are `photo`, `video`, or `animated_gif`.

### Trends

`Trend` represents a single trending topic on X. The `description`, `rank`, and `query` fields are omitted when unavailable. `TrendList` wraps the `GET /api/v1/trends` response. `total` is the full count of available trends before slicing, `woeid` is the region ID.

### Styles

`StyleProfile` is returned by the analyze style (`POST /api/v1/styles`) and get style (`GET /api/v1/styles/:username`) endpoints. It includes the cached tweets array with text, media, and timestamps. `StyleListItem` is the compact shape returned by `GET /api/v1/styles` (no tweets). `StyleComparison` wraps two full profiles for side-by-side comparison. `PerformanceAnalysis` adds engagement metrics (likes, retweets, replies, quotes, views, bookmarks) to each cached tweet. `isOwnAccount` is `true` when the analyzed username matches the authenticated user's linked X identity.

### Drafts

`Draft` represents a saved tweet draft. Optional `topic` and `goal` fields are omitted (not null) when not set. `DraftList` wraps paginated responses. Use `nextCursor` with the `afterCursor` query parameter to fetch subsequent pages. Maximum 50 drafts per page.

### Request Bodies

All request body types use optional fields for update operations (PATCH) and required fields for creation (POST). The API validates request bodies and returns `400 invalid_input` for missing or malformed fields.
